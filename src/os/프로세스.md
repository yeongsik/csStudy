# 프로세스

# 프로세스 개요

- 실행중인 프로그램
    - 실행 전에는 보조기억 장치에 있는 데이터 ⇒ 프로그램
    - 메모리에 적재 후 실행된다
- 프로세스 종류
    - 포그라운드 프로세스 (Foregound Process)
        - 사용자가 볼수 있는 공간에서 실행되는 프로세스
    - 백그라운드 프로세스 (Backgound Process)
        - 사용자가 볼수 없는 공간에서 실행되는 프로세스
            
            ⇒ 정해진 일만 수행 (사용자 상호작용X) ⇒ 데몬(daemon) , 서비스(service)
            

# 프로세스 제어 블록(Process Control Block)

- 모든 프로세스 실행을 위해 CPU가 필요 그러나 CPU 자원은 한정
    - 프로세스는 돌아가며 한정된 시간만큼 CPU를 사용한다.
    - 자신의 차례에 정해진 시간만큼 이용
    - 타이머 인터럽트가 발생하면 차례 양보
    
    ⇒ 자세한건 CPU 스케줄링에서
    
- 빠르게 번갈아 수행되는 프로세스들을 관리를 위해 사용하는 자료구조(자료를 저장하는 하나의 형태) ⇒ PCB
- 마치 상품(프로세스)에 달린 태그같은 정보
- 프로세스 생성 시 커널 영역에 생성, 프로세스 종료시 폐기

### PCB에 담기는 대표적인 정보

- 프로세스 ID(PID)
- 레지스터 값
    - 다시 자기 차례에서 실행을 재기하기 위한 값
    - 자신의 실행차례가 오면 이전까지 사용한 레지스터 중간값을 모두 복원 → 실행재개
    - 프로그램 카운터 , 스택포인터 등등
    - CPU이용할 때 레지스터 이용하며 실행 → 타이머 인터럽트 발생 (자기차례 종료) → 지금까지 자기가 이용했던 레지스터 값을 알고 있어야 실행재개 가능 (백업)
- 프로세스 상태
- CPU 스케줄링 정보
    - 프로세스가 언제 어떤 순서로 CPU할당 받을지에 대한 정보
- 메모리 정보
    - 프로세스가 어느 주소에 저장되어 있는지에 대한 정보
    - 페이지 테이블 정보
- 사용한 파일과 입출력 장치 정보
    - 할당된 입출력 장치, 사용중인(열린) 파일 정보
        - 실행과정 중 사용한 정보 PCB에 기록

 

⇒ 운영체제는 커널영역에 있는 PCB를 보고 프로세스를 일목요연하게 관리

# 문맥교환(Context Switch)

- 한 프로세스에서 실행되다가 다른 프로세스로 실행순서가 넘어갈 때 이뤄지는 작업
- 순서
    1. 기존 실행되던 프로세스는 지금까지 중간정보 백업
        - 프로그램 카운터 등 각종 레지스터 값, 메모리 정보, 열었던 파일, 사용한 입출력장치 등
        - 이러한 중간 정보 ⇒ 문맥(Context)
        - 다음 차례가 왔을 때 실행재개를 위한 정보
    2. 뒤이어 실행할 프로세스 문맥 복구
        1. 자연스럽게 실행 중인 프로세스 변경
- 여러 프로세스가 끊임없이 빠르게 번갈아가며 실행되는 원리
    
    실행 → 타이머인터럽트 → 문맥교환(백업,복구) → 실행 → 타이머 인터럽트 → 문맥교환 → 실행
    

# 프로세스의 메모리 영역

- PCB는 커널영역
- 사용자 영역에는 특정 영역에 나뉘어서 저장
    - 코드
    - 데이터
    - 힙
    - 스택

### 코드 영역 ( = 텍스트 영역 )

- 실행할 수 있는 코드, 기계어로 이루어진 명령어 저장
- 데이터가 아닌 CPU가 실행할 명령어가 담기기에 쓰기가 금지된 영역 ⇒ 명령어가 바뀌면 안되기 때문에

### 데이터 영역

- 잠깐 썼다가 없앨 데이터가 아닌 프로그램이 실행되는 동안 유지할 데이터 저장
    
    ex ) 전역 변수
    

### 힙 영역

- 프로그램을 만드는 사용자 즉 프로그래머가 직접 할당할 수 있는 저장 공간 (new() , malloc())
    
    ⇒ 자바에서 뉴 연산자로 객체 생성
    
- 해당 영역은 언젠간 메모리를 반환해야한다 → 현재 대부분의 언어에서 GC를 활용하여 자동으로 해당 영역을 정리한다 → 만약에 정리가 안될 경우 메모리 누수(Memory leac) 발생

### 스택 영역

- 데이터가 일시적으로 저장되는 공간
- 잠깐 쓰는 값들을 저장 → 매개변수 , 지역변수

⇒ 힙영역과 스택 영역 크기는 가변적 

- 일반적으로 힙영역은 낮은 주소 → 높은 주소로 할당
- 스택 영역은 높은 주소 → 낮은 주소로 할당

# 프로세스 상태와 계층 구조

- 운영체제는 프로세스 상태를 PCB에 기록해서 관리
- 모든 운영체제는 아니지만 대부분의 운영체제는 프로세스를 계층적으로 관리한다

### 프로세스 상태 (운영체제 마다 다를 수 있다)

- 생성 : 이제 막 메모리에 적재되어 PCB를 할당받은 상태 준비가 완료되면 준비상태로 간다.
- 준비 : 당장 CPU할당을 받을 수 있는 상태 , 자신 차례 때 실행상태로 변경 (디스패치)
- 실행 : CPU 할당 받은 실행 상태 , 시간 모두 사용시 타이머 인터럽트 발생 , 실행 도중 입출력 장치를 사용하면 입출력 작업이 끝날 때까지 대기상태
- 대기 : 프로세스가 입출력 작업을 하는 과정
    - 입출력 작업은 CPU보다 느리기에 대기상태로 변경
    - 입출력이 끝나면 (입출력 완료 인터럽트 발생) 준비상태로 이동
- 종료
    - PCB, 프로세스 메모리 영역 정리

### 프로세스 계층 구조

- 프로세스 실행 도중 시스템 콜을 통해 다른 프로세스 생성 가능
- 새 프로세스를 생성한 프로세스 : 부모 프로세스
- 부모 프로세스에 의해 생성된 프로세스 : 자식 프로세스
- 윈도우는 계층적 관리X , 리눅스,MacOS등은 사용하기 때문에 개발자로써 알고 있어야할 개념
- 부모 프로세스와 자식 프로세스는 각기 다른 PID를 가진다.
    - 일부 운영체제에서 자식 프로세스 PCB에 부모 프로세스 ID(PPID)를 명시하기도 함

### 프로세스 생성 기법 (부모→자식)

- 쉬운 비유 : 복제와 옷갈아입기
- 부모 프로세스에서 fork 시스템 호출로 자기 자신 복사본 → 즉 자식 프로세스 생성
- 자식 프로세스 exec 시스템 호출로 자신의 메모리공간을 다른 프로그램으로 교체

- fork - exec 구조
    - fork 시스템 호출
        - 복사본(자식프로세스) 생성
        - 부모 프로세스의 자원상속(메모리영역)
        - PID , 메모리 저장 위치는 다르다.
    - exec 시스템 호출
        - 메모리 공간을 새로운 프로그램으로 덮여쓰기
        - 코드 데이터 영역 실행할 프로그램으로 변경 , 나머지 영역은 초기화

⇒ 부모 자식 생성은 fork와 exec 시스템 호출 반복